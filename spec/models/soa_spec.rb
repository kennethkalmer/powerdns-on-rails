require 'spec_helper'

describe SOA do
  context "when new" do

    it "should be invalid by default" do
      expect(subject).not_to be_valid
    end

    it "should be unique per domain" do
      subject.domain = FactoryGirl.create(:domain)
      subject.valid?
      expect( subject.errors[:domain_id].size ).to eq(1)
    end

    it "should require a primary NS" do
      subject.valid?
      expect( subject.errors[:primary_ns].size ).to eq(1)
    end

    it "should require a contact" do
      subject.valid?
      expect( subject.errors[:contact].size ).to eq(1)
    end

    it "should require a valid email address for the contact" do
      subject.contact = 'test'
      subject.valid?
      expect( subject.errors[:contact].size ).to eq(1)

      subject.contact = 'test@example'
      subject.valid?
      expect( subject.errors[:contact].size ).to eq(1)

      subject.contact = 'test@example.com'
      subject.valid?
      expect( subject.errors[:contact].size ).to eq(0)
    end

    it "should flip the first period in the contact to an @" do
      subject.contact = 'test.example.com'
      expect(subject.contact).to eq('test@example.com')

      subject.contact = 'test@example.com'
      expect(subject.contact).to eq('test@example.com')
    end

    it "should have an autogenerated serial" do
      expect(subject.serial).not_to be_nil
    end

    it "should only accept positive integers as serials" do
      subject.serial = -2008040101
      subject.valid?
      expect( subject.errors[:serial].size ).to eq(1)

      subject.serial = 'ISBN123456789'
      subject.valid?
      expect( subject.errors[:serial].size ).to eq(1)

      subject.serial = 2008040101
      subject.valid?
      expect( subject.errors[:serial].size ).to eq(0)
    end

    it "should require a refresh time" do
      subject.valid?
      expect( subject.errors[:refresh].size ).to eq(1)
    end

    it "should only accept positive integers as refresh time" do
      subject.refresh = -86400
      subject.valid?
      expect( subject.errors[:refresh].size ).to eq(1)

      subject.refresh = '12h'
      subject.valid?
      expect( subject.errors[:refresh].size ).to eq(1)

      subject.refresh = 2008040101
      subject.valid?
      expect( subject.errors[:refresh].size ).to eq(0)
    end

    it "should require a retry time" do
      expect(subject).to have(1).error_on(:retry)
    end

    it "should only accept positive integers as retry time" do
      subject.retry = -86400
      subject.valid?
      expect( subject.errors[:retry].size ).to eq(1)

      subject.retry = '15m'
      subject.valid?
      expect( subject.errors[:retry].size ).to eq(1)

      subject.retry = 2008040101
      subject.valid?
      expect( subject.errors[:retry].size ).to eq(0)
    end

    it "should require a expiry time" do
      subject.valid?
      expect( subject.errors[:expire].size ).to eq(1)
    end

    it "should only accept positive integers as expiry times" do
      subject.expire = -86400
      subject.valid?
      expect( subject.errors[:expire].size ).to eq(1)

      subject.expire = '2w'
      subject.valid?
      expect( subject.errors[:expire].size ).to eq(1)

      subject.expire = 2008040101
      subject.valid?
      expect( subject.errors[:expire].size ).to eq(0)
    end

    it "should require a minimum time" do
      subject.valid?
      expect( subject.errors[:minimum].size ).to eq(1)
    end

    it "should only accept positive integers as minimum times" do
      subject.minimum = -86400
      subject.valid?
      expect( subject.errors[:minimum].size ).to eq(1)

      subject.minimum = '3h'
      subject.valid?
      expect( subject.errors[:minimum].size ).to eq(1)

      subject.minimum = 10800
      subject.valid?
      expect( subject.errors[:minimum].size ).to eq(0)
    end

    it "should not allow a minimum of more than 10800 seconds (RFC2308)" do
      subject.minimum = 84600
      subject.valid?
      expect( subject.errors[:minimum].size ).to eq(1)
    end

  end

  context "when created" do
    before(:each) do
      @domain = FactoryGirl.create(:domain)
      @domain.soa_record.destroy

      @soa = SOA.new(
        :domain => @domain,
        :primary_ns => 'ns1.example.com',
        :contact => 'dnsadmin@example.com',
        :refresh => 7200,
        :retry => 1800,
        :expire => 604800,
        :minimum => 10800
      )
    end

    it "should have the convenience fields populated before save" do
      expect(@soa.primary_ns).to eql('ns1.example.com')
    end

    it "should create a content field from the convenience fields" do
      expect(@soa.save).to be_truthy

      expect(@soa.content).to match(/ns1\.example\.com dnsadmin@example.com \d+ 7200 1800 604800 10800/)
    end

  end

  context "serial numbers" do
    before(:each) do
      @soa = FactoryGirl.create(:domain).soa_record
    end

    it "should have an easy way to update (without saving)" do
      serial = @soa.serial
      expect(serial).not_to be_nil

      @soa.update_serial

      expect(@soa.serial).not_to be( serial )
      expect(@soa.serial).to be >( serial )

      @soa.reload
      expect(@soa.serial).to eql( serial )
    end

    it "should have an easy way to update (with saving)" do
      serial = @soa.serial
      expect(serial).not_to be_nil

      @soa.update_serial!

      expect(@soa.serial).not_to be( serial )
      expect(@soa.serial).to be >( serial )

      @soa.reload
      expect(@soa.serial).not_to be( serial )
    end

    it "should update in sequence for the same day" do
      date_segment = Time.now.strftime( "%Y%m%d" )

      expect(@soa.serial.to_s).to eql( date_segment + '00' )

      10.times { @soa.update_serial! }

      expect(@soa.serial.to_s).to eql( date_segment + '10' )
    end
  end

  context "when serializing to XML" do
    before(:each) do
      @soa = FactoryGirl.create(:domain).soa_record
    end

    it "should make an soa tag" do
      expect(@soa.to_xml).to match(/<soa>/)
    end

    it "should have the custom soa attributes present" do
      xml = @soa.to_xml

      expect(xml).to match(/<primary\-ns/)
      expect(xml).to match(/<contact/)
      expect(xml).to match(/<serial/)
      expect(xml).to match(/<minimum/)
      expect(xml).to match(/<expire/)
      expect(xml).to match(/<refresh/)
      expect(xml).to match(/<retry/)
    end

    it "should preserve original #to_xml options" do
      xml = @soa.to_xml :skip_instruct => true
      expect(xml).not_to match(/<\?xml/)
    end
  end
end
